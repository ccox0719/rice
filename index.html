<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Bomb Diffusal â€“ Pyramid</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121821; --ink:#e7eef7; --muted:#9fb0c6; --accent:#5dd2ff; --danger:#ff6b6b; --ok:#7dff91; --warn:#ffd166;
      --card:#1c2531; --card-face:#202b39; --shadow:0 8px 26px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Helvetica Neue,Arial,sans-serif;background:var(--bg);color:var(--ink);} 
    button,input,select{font:inherit}

    /* Layout */
    .app{max-width:820px;margin:0 auto;padding:10px 10px 80px;display:grid;gap:10px}
    .topbar{position:sticky;top:0;background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.7));backdrop-filter:blur(10px);z-index:10;padding:8px;border-bottom:1px solid #1a2431}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .row > *{flex:0 0 auto}
    .spacer{flex:1}
    .btn{background:#16202c;border:1px solid #223144;color:var(--ink);padding:6px 10px;border-radius:10px;cursor:pointer;box-shadow:var(--shadow)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}
    .btn.primary{background:var(--accent);color:#071019;border-color:#50c6f2}
    .btn.warn{background:var(--warn);color:#201b00}
    .btn.danger{background:var(--danger);color:#240000}
    .seg{display:flex;border:1px solid #223144;border-radius:10px;overflow:hidden}
    .seg button{border:0;background:#121a24;color:var(--muted);padding:6px 10px}
    .seg button.active{background:var(--accent);color:#041018}

    .table{display:grid;gap:8px}
    .players{display:grid;gap:10px}
    @media (min-width:560px){.players{grid-template-columns:1fr 1fr}}

    .panel{background:var(--panel);border:1px solid #1a2431;border-radius:16px;padding:10px;box-shadow:var(--shadow)}
    .panel.current{outline:2px solid var(--accent)}

    .p-head{display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .tag{font-size:.8rem;color:var(--muted);padding:2px 8px;border:1px solid #223144;border-radius:999px}

    .pyr{display:grid;grid-template-columns:repeat(3,1fr);gap:4px;align-items:end}
    .col{display:grid;gap:4px}

    .card{height:34px;border-radius:10px;border:1px solid #2a3a50;background:var(--card);display:flex;align-items:center;justify-content:center;color:var(--ink);opacity:.95;box-shadow:inset 0 0 0 1px #101822}
    .card.face{background:linear-gradient(180deg,#26364d,#1b2736)}
    .card.joker{background:linear-gradient(180deg,#2a1b36,#1c0f26)}
    .card.hidden{filter:blur(2px);opacity:.55}
    .card.hazard{outline:2px dashed var(--danger)}
    .card.core{background:linear-gradient(180deg,#1c2a38,#24374d)}
    .card.exposed{box-shadow:0 0 0 2px rgba(93,210,255,.5) inset}

    .hand{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .hbtn{min-width:42px;padding:8px;border-radius:12px;border:1px solid #2a3a50;background:var(--card-face);color:var(--ink)}
    .hbtn.joker{background:#2a173a}

    .core{display:flex;gap:8px;align-items:center}
    .log{max-height:120px;overflow:auto;font-size:.85rem;color:var(--muted);padding:6px;border:1px solid #223144;border-radius:10px;background:#0e141d}
    .tiny{font-size:.85rem;color:var(--muted)}

    .targeting{border:2px dashed var(--accent)}

    /* Compact tap areas for iPhone */
    .tap{touch-action:manipulation}
  </style>
</head>
<body>
  <div class="topbar row">
    <button class="btn primary" id="newGameBtn">New Game</button>
    <div class="seg" role="tablist" aria-label="Mode">
      <button class="tap" id="modePassPlay" aria-pressed="true" class="active">Pass&Play</button>
      <button class="tap" id="modeVsAI">Vs AI</button>
    </div>
    <div class="row">
      <label class="tiny">Bots:</label>
      <select id="botCount">
        <option value="3">3</option>
        <option value="2">2</option>
        <option value="1">1</option>
        <option value="0">0</option>
      </select>
    </div>
    <div class="spacer"></div>
    <button class="btn" id="endTurnBtn">End Turn</button>
  </div>

  <div class="app">
    <div class="panel core" id="corePanel">
      <div class="p-head"><strong>Core</strong><span class="tag" id="coreStatus">Hidden</span><span class="tag" id="reshuffles">Reshuffles: 0/1</span></div>
      <div class="core">
        <div id="coreCard" class="card core hidden">?</div>
        <div class="tiny">Exposes when <strong>any player clears their bottom row (3)</strong>. Joker at Core auto-clears.</div>
      </div>
    </div>

    <div class="players" id="players"></div>

    <div class="panel">
      <div class="p-head"><strong>Log</strong></div>
      <div class="log" id="log"></div>
    </div>
  </div>

<script>
(function(){
  // ======= Game Constants =======
  const JACK=11, QUEEN=12, KING=13, JOKER=0;
  const MAX_HAND=4;
  const MAX_CASCADE=3;
  const ALLOW_RESHUFFLES=1; // single reshuffle, per rules

  // ======= State =======
  let S = null; // global game state

  function makeDeck(){
    const d=[]; for(let s=0;s<4;s++){ for(let v=1;v<=13;v++) d.push(v); } d.push(JOKER,JOKER); shuffle(d); return d;
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

  function deep(o){ return JSON.parse(JSON.stringify(o)); }

  // Pyramid helpers (columns 0..2; levels bottom=0, middle=1, top=2 (only col 1 has top))
  function newPlayer(name, isBot){
    return {name, isBot, hand:[], slots:[[null,null,null],[null,null,null],[null,null,null]], eliminated:false};
  }
  function dealFaceDown(){ return drawCard(); }
  function drawCard(){
    if(!S.deck.length){
      if(S.reshuffles < ALLOW_RESHUFFLES && S.discard.length){
        log(`Deck exhausted. Reshuffling ...`);
        shuffle(S.discard); S.deck = S.discard; S.discard = []; S.reshuffles++;
        updateReshuffles();
      } else {
        // no more cards â†’ loss
        S.loss = true; return null;
      }
    }
    return S.deck.pop();
  }
  function discard(v){ S.discard.push(v); }

  function initGame(players=4, bots=3){
    S = { deck:makeDeck(), discard:[], reshuffles:0, turn:0, current:0, loss:false,
          players:[], core:{card:null, revealed:false, exposed:false}, mode:"pass" };
    const names=["P1","P2","P3","P4"];
    for(let i=0;i<players;i++) S.players.push(newPlayer(names[i], i < bots));

    // Deal pyramids: bottom row face-up
    for(const P of S.players){
      for(let col=0;col<3;col++) P.slots[col][0] = {val:dealFaceDown(), visible:true, hazard:false};
      // middle: col 0 and 1 hidden
      for(const col of [0,1]) P.slots[col][1] = {val:dealFaceDown(), visible:false, hazard:false};
      // top: col 1 hidden
      P.slots[1][2] = {val:dealFaceDown(), visible:false, hazard:false};
    }
    // Deal hands
    for(const P of S.players){ for(let i=0;i<MAX_HAND;i++){ const c=drawCard(); if(c==null){render();return;} P.hand.push(c);} }
    // Core face-down
    S.core.card = dealFaceDown();

    logClear();
    log(`New game started. ${S.players.filter(p=>p.isBot).length} bot(s).`);
    render();
    maybeRunAITurn();
  }

  // ======= Exposure & Targeting =======
  function supportsEmpty(P, col, lvl){
    if(lvl===0) return true;
    if(lvl===1){
      if(col===0) return P.slots[0][0]===null && P.slots[1][0]===null;
      if(col===1) return P.slots[1][0]===null && P.slots[2][0]===null;
    }
    if(lvl===2){
      return P.slots[0][1]===null && P.slots[1][1]===null;
    }
    return false;
  }
  function isExposed(P, col, lvl){
    const s = P.slots[col][lvl]; if(!s) return false;
    if(lvl===0) return true; // bottom always structurally exposed
    // Hazard Lock baked into supportsEmpty requirement (if a support has any card incl. hazard, not empty)
    return supportsEmpty(P,col,lvl);
  }
  function exposedPositions(P){
    const out=[];
    for(let col=0;col<3;col++) for(let lvl=0;lvl<3;lvl++) if(P.slots[col][lvl] && isExposed(P,col,lvl)) out.push([col,lvl]);
    return out;
  }
  function bottomRowCleared(P){ return P.slots[0][0]==null && P.slots[1][0]==null && P.slots[2][0]==null; }

  function checkCoreExposure(){
    if(!S.core.exposed){
      for(const P of S.players){ if(bottomRowCleared(P)){ S.core.exposed=true; S.core.revealed=true; log(`Core is now exposed!`); break; } }
      if(S.core.exposed && S.core.card===JOKER){ log(`Core is Joker â†’ auto-clear. You win!`); S.core.card=null; }
    }
  }

  // ======= Turn & Play =======
  function currentPlayer(){ return S.players[S.current]; }

  function hasMatch(hand, val){ return val===JOKER || hand.includes(val) || hand.includes(JOKER); }
  function pickBaseFor(hand, val){
    if(val===JOKER){ const pool=hand.filter(c=>c!==JOKER); return pool.length? Math.min(...pool) : JOKER; }
    if(hand.includes(val)) return val; if(hand.includes(JOKER)) return JOKER; return null;
  }

  function pathNext(col,lvl){
    if(col===0) return (lvl===0)? [0,1] : null;
    if(col===2) return null;
    if(col===1){ if(lvl===0) return [1,1]; if(lvl===1) return [1,2]; return null; }
  }

  function clearAt(P, col,lvl, base){
    let clears=0, royals=[];
    for(let step=0; step<MAX_CASCADE; step++){
      const s = P.slots[col]?.[lvl]; if(!s) break;
      if(!isExposed(P,col,lvl)) break;
      const tv = s.val; const match = (tv===JOKER) || (base===JOKER) || (base===tv);
      if(!match) break;
      // clear
      P.slots[col][lvl]=null; discard(tv); clears++;
      if(tv===JACK||tv===QUEEN||tv===KING) royals.push(tv);
      // after removal, maybe core exposure (if my bottom row now empty)
      checkCoreExposure();
      // move to next in column
      const nxt = pathNext(col,lvl); if(!nxt) break; col=nxt[0]; lvl=nxt[1];
    }
    return {clears, royals};
  }

  function applyJack(me){
    const nei = S.players[(S.current+1)%S.players.length];
    if(!me.hand.length && !nei.hand.length) return;
    // give least-useful
    if(me.hand.length){
      const exVals = new Set(exposedPositions(me).map(([c,l])=>me.slots[c][l].val));
      const score = c => c===JOKER?2 : exVals.has(c)?1:0;
      me.hand.sort((a,b)=>score(a)-score(b));
      const give = me.hand.shift();
      if(nei.hand.length<MAX_HAND) nei.hand.push(give); else me.hand.unshift(give);
    }
    if(nei.hand.length && me.hand.length<MAX_HAND){ me.hand.push(nei.hand.splice((Math.random()*nei.hand.length)|0,1)[0]); }
  }
  function applyQueen(me){
    // reveal my hidden pref: (0,1)->(1,1)->(1,2), else teammate, else core
    const order=[[0,1],[1,1],[1,2]];
    let done=false;
    for(const [c,l] of order){ const s=me.slots[c][l]; if(s && !s.visible){ s.visible=true; done=true; break; } }
    if(done) return;
    for(let i=1;i<S.players.length;i++){
      const P = S.players[(S.current+i)%S.players.length];
      for(const [c,l] of order){ const s=P.slots[c][l]; if(s && !s.visible){ s.visible=true; done=true; break; } }
      if(done) break;
    }
    if(!done && !S.core.revealed){ S.core.revealed=true; }
  }
  function applyKing(me){ for(let i=0;i<2;i++){ if(me.hand.length>=MAX_HAND) break; const c=drawCard(); if(c==null)return; me.hand.push(c);} }

  function endOfAttemptDraw(me){ if(me.hand.length<MAX_HAND){ const c=drawCard(); if(c==null)return; me.hand.push(c);} }

  function placeHazard(me){
    const c=drawCard(); if(c==null)return;
    const order=[[0,0],[1,0],[2,0],[0,1],[1,1],[1,2]];
    for(const [col,lvl] of order){ if(me.slots[col][lvl]==null){ me.slots[col][lvl]={val:c,visible:true,hazard:true}; return; } }
    discard(c); // fallback
  }

  function attemptPlay(target){
    const me = currentPlayer();
    if(S.loss || S.core.card===null) return;

    let tType=target.type; // 'pyr' or 'core'
    let base; let tv;

    if(tType==='core'){
      if(!(S.core.exposed && S.core.card!=null)){ toast('Core not targetable'); return; }
      tv=S.core.card; base = pickBaseFor(me.hand, tv) ?? me.hand[0];
      // play base
      me.hand.splice(me.hand.indexOf(base),1); discard(base);
      const match = (tv===JOKER)||(base===JOKER)||(base===tv);
      if(match){ log(`${me.name} clears CORE with ${show(base)}.`); discard(tv); S.core.card=null; render(); checkEnd(); return; }
      else { log(`${me.name} failed on CORE with ${show(base)} â†’ Hazard.`); placeHazard(me); endOfAttemptDraw(me); nextTurn(); return; }
    }

    // Pyramid target
    const {pid,col,lvl} = target; const P = S.players[pid];
    if(pid!==S.current){ toast('You can only target your own exposed cards.'); return; }
    if(!isExposed(P,col,lvl)){ toast('Target not exposed'); return; }
    tv = P.slots[col][lvl].val; base = pickBaseFor(me.hand, tv) ?? me.hand[0];
    me.hand.splice(me.hand.indexOf(base),1); discard(base);

    const match = (tv===JOKER)||(base===JOKER)||(base===tv);
    if(!match){ log(`${me.name} failed vs ${lab(col,lvl)} (${show(tv)}) with ${show(base)} â†’ Hazard.`); placeHazard(me); endOfAttemptDraw(me); nextTurn(); return; }

    const {clears, royals} = clearAt(P,col,lvl,base);
    log(`${me.name} cleared ${clears} card(s) using ${show(base)}.`);

    // Royals in order
    for(const r of royals){
      if(r===JACK){ log(`Jack effect: swap 1 with right neighbor.`); applyJack(me); }
      if(r===QUEEN){ log(`Queen effect: reveal 1 hidden.`); applyQueen(me); }
      if(r===KING){ log(`King effect: draw 2.`); applyKing(me); }
    }

    // Auto-clear core if Joker and just exposed (handled in checkCoreExposure within clearAt)

    endOfAttemptDraw(me);
    nextTurn();
  }

  function nextTurn(){ if(S.loss){ render(); return; } checkEnd(); if(S.core.card===null || S.loss) { render(); return; } S.current=(S.current+1)%S.players.length; S.turn++; render(); maybeRunAITurn(); }

  function checkEnd(){
    if(S.core.card===null){ toast('ðŸ’¥ Diffused! You win.'); }
    if(S.loss){ toast('Deck exhausted. ðŸ’£ Boom â€“ you lose.'); }
  }

  // ======= Simple AI (greedy exact-first) =======
  function aiChooseTarget(pid){
    const me = S.players[pid];
    // exposed in my pyramid
    const ex = exposedPositions(me);
    const hazards = ex.filter(([c,l])=>me.slots[c][l].hazard);
    const normals = ex.filter(([c,l])=>!me.slots[c][l].hazard);
    const hand = me.hand;

    const canExact = (t)=>{ const v=me.slots[t[0]][t[1]].val; return v===JOKER || hand.includes(v); };
    const canMatch = (t)=>{ const v=me.slots[t[0]][t[1]].val; return hasMatch(hand,v); };

    // 1) core exact
    if(S.core.exposed && S.core.card!=null){ if(S.core.card===JOKER || hand.includes(S.core.card)) return {type:'core'}; }
    // 2) hazard exact
    const eh = hazards.filter(canExact).sort((a,b)=>a[1]-b[1]); if(eh.length) return {type:'pyr',pid:pid,col:eh[0][0],lvl:eh[0][1]};
    // 3) normal exact
    const en = normals.filter(canExact).sort((a,b)=>a[1]-b[1]); if(en.length) return {type:'pyr',pid:pid,col:en[0][0],lvl:en[0][1]};
    // 4) core via joker
    if(S.core.exposed && S.core.card!=null && hasMatch(hand,S.core.card)) return {type:'core'};
    // 5) hazard via joker
    const hj = hazards.filter(canMatch).sort((a,b)=>a[1]-b[1]); if(hj.length) return {type:'pyr',pid:pid,col:hj[0][0],lvl:hj[0][1]};
    // 6) normal via joker
    const nj = normals.filter(canMatch).sort((a,b)=>a[1]-b[1]); if(nj.length) return {type:'pyr',pid:pid,col:nj[0][0],lvl:nj[0][1]};
    // 7) fallback lowest exposed
    const all = ex.sort((a,b)=>a[1]-b[1]); if(all.length) return {type:'pyr',pid:pid,col:all[0][0],lvl:all[0][1]};
    // else if core exposed but no match, still try core (will fail)
    if(S.core.exposed && S.core.card!=null) return {type:'core'};
    return null;
  }

  function maybeRunAITurn(){
    const P = currentPlayer();
    if(!P.isBot || S.loss || S.core.card===null) return;
    // small delay for UX
    setTimeout(()=>{
      const target = aiChooseTarget(S.current) || {type:'pyr',pid:S.current,col:1,lvl:0};
      attemptPlay(target);
    }, 300);
  }

  // ======= UI =======
  const elPlayers = document.getElementById('players');
  const elLog = document.getElementById('log');
  const elCoreCard = document.getElementById('coreCard');
  const elCoreStatus = document.getElementById('coreStatus');
  const elReshuffles = document.getElementById('reshuffles');

  function updateReshuffles(){ elReshuffles.textContent = `Reshuffles: ${S.reshuffles}/${ALLOW_RESHUFFLES}`; }

  function show(v){ if(v===JOKER) return 'ðŸƒ'; if(v===1) return 'A'; if(v===11) return 'J'; if(v===12) return 'Q'; if(v===13) return 'K'; return String(v); }
  function lab(col,lvl){ return `C${col}L${lvl}`; }

  function render(){
    // Core
    if(S.core.card==null){ elCoreCard.textContent='âœ“'; elCoreCard.classList.remove('hidden'); elCoreStatus.textContent='Cleared'; }
    else if(S.core.exposed){ elCoreCard.textContent= show(S.core.card); elCoreCard.classList.remove('hidden'); elCoreCard.classList.add('exposed'); elCoreStatus.textContent='Exposed'; }
    else { elCoreCard.textContent='?'; elCoreCard.classList.add('hidden'); elCoreCard.classList.remove('exposed'); elCoreStatus.textContent='Hidden'; }
    updateReshuffles();

    // Players
    elPlayers.innerHTML='';
    S.players.forEach((P,idx)=>{
      const panel = document.createElement('div'); panel.className='panel'+(idx===S.current?' current':'');
      const head = document.createElement('div'); head.className='p-head';
      head.innerHTML = `<strong>${P.name} ${P.isBot?'ðŸ¤–':''}</strong><span class="tag">${idx===S.current?'Your turn':''}</span>`;
      panel.appendChild(head);

      // Pyramid grid
      const pyr = document.createElement('div'); pyr.className='pyr';
      for(let col=0;col<3;col++){
        const colEl=document.createElement('div'); colEl.className='col';
        // stack from bottom to top visually
        for(let lvl=2; lvl>=0; lvl--){
          const s = P.slots[col][lvl];
          if(!s){ const spacer=document.createElement('div'); spacer.style.height='6px'; colEl.appendChild(spacer); continue; }
          const card=document.createElement('button'); card.className='card tap';
          let classes=['card']; if(s.hazard) classes.push('hazard'); if(!s.visible) classes.push('hidden');
          const isFace = (s.val===JACK||s.val===QUEEN||s.val===KING);
          if(isFace) classes.push('face'); if(s.val===JOKER) classes.push('joker');
          if(isExposed(P,col,lvl)) classes.push('exposed');
          card.className = classes.join(' ');
          card.textContent = s.visible? show(s.val): 'â– ';
          if(idx===S.current && !P.isBot && isExposed(P,col,lvl)){
            card.addEventListener('click',()=>attemptPlay({type:'pyr',pid:idx,col,lvl}));
          }
          colEl.appendChild(card);
        }
        pyr.appendChild(colEl);
      }
      panel.appendChild(pyr);

      // Hand (only show for current player in pass&play; always show for humans in vs-AI)
      const showHand = (S.mode==='ai') ? (!P.isBot) : (idx===S.current && !P.isBot);
      const handDiv=document.createElement('div'); handDiv.className='hand';
      if(showHand){
        P.hand.forEach((v,i)=>{
          const hb=document.createElement('button'); hb.className='hbtn tap'+(v===JOKER?' joker':''); hb.textContent=show(v);
          hb.disabled=true; // cards are auto-chosen when you tap a target
          handDiv.appendChild(hb);
        });
      } else {
        const t=document.createElement('div'); t.className='tiny'; t.textContent = P.isBot? 'Bot' : (idx===S.current? 'Your hand (hidden)':'Hidden');
        handDiv.appendChild(t);
      }
      panel.appendChild(handDiv);

      elPlayers.appendChild(panel);
    });
  }

  // ======= Log & Toast =======
  function log(msg){ const time = String(S.turn).padStart(2,'0'); elLog.innerHTML += `[${time}] ${msg}<br/>`; elLog.scrollTop=elLog.scrollHeight; }
  function logClear(){ elLog.innerHTML=''; }
  function toast(msg){ log(msg); }

  // ======= Controls =======
  const newGameBtn=document.getElementById('newGameBtn');
  const modePassPlay=document.getElementById('modePassPlay');
  const modeVsAI=document.getElementById('modeVsAI');
  const botCountSel=document.getElementById('botCount');
  const endTurnBtn=document.getElementById('endTurnBtn');

  newGameBtn.addEventListener('click', ()=>{ initGame(4, parseInt(botCountSel.value,10)); });
  modePassPlay.addEventListener('click', ()=>{ S && (S.mode='pass'); modePassPlay.classList.add('active'); modeVsAI.classList.remove('active'); render(); });
  modeVsAI.addEventListener('click', ()=>{ S && (S.mode='ai'); modeVsAI.classList.add('active'); modePassPlay.classList.remove('active'); render(); });
  endTurnBtn.addEventListener('click', ()=>{ if(currentPlayer()?.isBot) return; // human only
    // Allow skipping your action (for testing). Apply fail consequence: hazard + draw
    attemptPlay({type:'pyr',pid:S.current,col:1,lvl:0}); // best-effort fallback â€“ will validate & fail if not exposed
  });

  // Start a default game
  initGame(4,3);
})();
</script>
</body>
</html>
