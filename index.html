<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Bomb Diffusal ‚Äì Pyramid</title>
<style>
  :root{
    --bg:#0e1116; --card:#171b22; --ink:#e7edf7; --muted:#9fb0c3;
    --accent:#65c3ff; --accent2:#87f7a1; --warn:#ffb46b; --danger:#ff6b6b;
    --grid: 8px; --r: 12px; --touch: 44px;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);-webkit-font-smoothing:antialiased}
  .app{max-width:900px;margin:0 auto;padding:calc(env(safe-area-inset-top,0) + var(--grid)) var(--grid) calc(env(safe-area-inset-bottom,0) + var(--grid));display:grid;gap:var(--grid)}
  header{display:flex;gap:var(--grid);align-items:center;justify-content:space-between;position:sticky;top:0;background:linear-gradient(180deg, rgba(14,17,22,0.98), rgba(14,17,22,0.6) 75%, rgba(14,17,22,0));backdrop-filter:blur(8px);z-index:5;padding-bottom:var(--grid)}
  .title{font-weight:700;letter-spacing:.3px}
  .row{display:flex;gap:var(--grid);align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border:1px solid #243143;border-radius:999px;color:var(--muted);font-size:12px}
  .btn{min-height:var(--touch);padding:10px 14px;border-radius:10px;border:1px solid #243143;background:linear-gradient(180deg,#1a2029,#131821);color:var(--ink);font-weight:600}
  .btn:disabled{opacity:.55}
  .btn-primary{border-color:#2a3c50;background:linear-gradient(180deg,#1c2a36,#14202a);box-shadow:inset 0 1px 0 #274057}
  .btn-ghost{background:transparent}
  .btn-danger{border-color:#5a2b2b;background:linear-gradient(180deg,#2a1717,#1b1212);color:#ffd6d6}
  .board{
    display:grid;gap:var(--grid);
    grid-template-columns: 1fr; 
  }
  @media(min-width:560px){
    .board{grid-template-columns: 1fr 1fr;}
  }
  .seat{
    border:1px solid #223044;border-radius:var(--r);padding:10px;background:linear-gradient(180deg,#121721,#0e1219);
    display:grid;grid-template-rows:auto auto auto;gap:8px;
  }
  .seat.me{outline:1px solid #2c4056;box-shadow:0 0 0 2px #203042 inset}
  .seat .head{display:flex;justify-content:space-between;align-items:center}
  .seat .head .name{font-weight:700}
  .meta{font-size:12px;color:var(--muted)}
  .pyramid{display:grid;gap:4px}
  .row3,.row2,.row1{display:flex;gap:4px;justify-content:center}
  .card{
    min-width:40px;min-height:48px;border-radius:8px;padding:6px 4px;background:var(--card);
    display:flex;align-items:center;justify-content:center;border:1px solid #243143;color:var(--ink);
    font-weight:700; font-feature-settings:"tnum" 1; position:relative;
  }
  .card.hazard{border-color:#4d2d16;box-shadow:inset 0 0 0 2px #4d2d16}
  .card.hidden{color:#546170}
  .card.exposed{outline:2px solid rgba(101,195,255,.35)}
  .card.core{background:linear-gradient(180deg,#172033,#101520)}
  .stack{display:flex;gap:4px;flex-wrap:wrap}
  .hand{display:flex;gap:6px;flex-wrap:wrap}
  .chip{min-width:38px;height:38px;border-radius:10px;background:var(--card);border:1px solid #243143;display:flex;align-items:center;justify-content:center;font-weight:800}
  .chip.sel{outline:2px solid var(--accent)}
  .helper-bar{display:flex;gap:6px;flex-wrap:wrap}
  .status{font-size:13px;color:var(--muted)}
  .log{max-height:160px;overflow:auto;border:1px solid #223044;border-radius:10px;padding:8px;background:#0b0e13}
  .toast{position:fixed;left:50%;bottom:calc(16px + env(safe-area-inset-bottom,0));transform:translateX(-50%);background:#101720;border:1px solid #2a3c50;padding:10px 14px;border-radius:12px;z-index:100;color:var(--ink);display:none}
  .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .grow{flex:1}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="row">
      <div class="title">üí£ Bomb Diffusal ‚Äì Pyramid</div>
      <div class="pill" id="variantTag">Core exposes on bottom row clear</div>
    </div>
    <div class="row">
      <button class="btn btn-ghost" id="newGameBtn">New Game</button>
      <button class="btn btn-primary" id="quickStartBtn">Quick Start</button>
    </div>
  </header>

  <section class="row" id="setup">
    <div class="pill">Seats:</div>
    <div class="row">
      <label class="pill"><input type="checkbox" class="seatpick" data-seat="0" checked/> P0 (You)</label>
      <label class="pill"><input type="checkbox" class="seatpick" data-seat="1"/> P1 (Human)</label>
      <label class="pill"><input type="checkbox" class="seatpick" data-seat="2"/> P2 (Human)</label>
      <label class="pill"><input type="checkbox" class="seatpick" data-seat="3"/> P3 (Human)</label>
    </div>
    <div class="pill">Unchecked seats are AI</div>
    <div class="row">
      <label class="pill"><input type="checkbox" id="helpersOn" checked/> Across-seat helper enabled</label>
      <label class="pill"><input type="checkbox" id="hazardBite"/> Hazard Bite (no draw on fail)</label>
      <label class="pill"><input type="checkbox" id="twoReshuffles"/> Two reshuffles</label>
    </div>
  </section>

  <section class="row">
    <div class="pill" id="turnInfo">‚Äì</div>
    <div class="pill" id="deckInfo">‚Äì</div>
    <div class="pill" id="coreInfo">Core: hidden</div>
  </section>

  <section class="board" id="board"></section>

  <section class="row">
    <div class="status" id="status">Tap a card in hand, then tap an exposed target.</div>
    <div class="grow"></div>
    <button class="btn btn-danger" id="endTurnBtn">End Turn</button>
  </section>

  <section>
    <div class="log" id="log"></div>
  </section>
</div>

<div class="toast" id="toast"></div>

<script>
/*==========================================================
   Bomb Diffusal ‚Äì Pyramid (web, minimal)
   - 4 seats (0..3) in 2x2 layout: 0 top-left, 1 top-right, 2 bottom-left, 3 bottom-right
   - Across seat: s ^ 2 (0<->2, 1<->3)
   - Core exposes when any player's bottom row (3 cards) is cleared
   - Helper: opposite seat may contribute one helper card to adjust base by ¬±helper value
     Success if (base == target) OR (base is Joker) OR (target is Joker) OR (base ¬± helper == target).
     Helper Joker: choose + or ‚àí any amount (auto-match). We auto-choose the needed sign in AI; humans pick.
==========================================================*/
const JACK=11, QUEEN=12, KING=13, JOKER=0;
const RANKS=[1,2,3,4,5,6,7,8,9,10,JACK,QUEEN,KING];

const S = { cfg:{}, rng:Math.random, state:null, ui:{} };

function log(msg){ const el=gid('log'); el.innerHTML = `<div>${msg}</div>` + el.innerHTML; }
function toast(msg){ const t=gid('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1200); }
function gid(id){ return document.getElementById(id); }

function makeDeck(){
  const d=[];
  for(let s=0;s<4;s++) d.push(...RANKS);
  d.push(JOKER,JOKER);
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function deal(deck){ return deck.pop(); }

function seatName(i){ return `P${i}`; }
function acrossOf(i){ return i^2; }
function vName(v){ return v===0?'J‚ôõ':'A2345678910JQK'.split('')[v===10?9:v-1] || v; }

function newGame(cfg){
  const state = {
    turn:0, current:0, over:false, winner:null,
    deck: makeDeck(), discard:[], reshuffles:0,
    core:{ card: dealPeek(), revealed:false, exposed:false, cleared:false },
    players:[],
    selectedHandCard:null, selectedTarget:null, pendingHelper:null
  };
  function dealPeek(){ return S._deal(state); }
  // patch draw/reshuffle logic
  state.draw = function(n=1){
    const out=[];
    for(let i=0;i<n;i++){
      if(state.deck.length===0){
        if(state.discard.length>0 && state.reshuffles < (cfg.twoReshuffles?2:1)){
          shuffle(state.discard); state.deck = state.discard; state.discard=[]; state.reshuffles++;
          log(`üîÅ Reshuffle ${state.reshuffles}`);
        } else { return out; }
      }
      out.push(state.deck.pop());
    }
    return out;
  };
  S._deal = function(st){ // low-level deal that respects reshuffle
    const a = st.draw(1);
    return a.length? a[0] : null;
  };
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

  // Build players with pyramids (3-2-1)
  for(let p=0;p<4;p++){
    const py = [[null,null,null],[null,null,null],[null,null,null]];
    // bottom row 3 face-up
    for(const c of [0,1,2]) py[c][0] = { val: dealPeek(), visible:true, hazard:false };
    // middle 2 hidden: at columns 0 and 1
    for(const c of [0,1]) py[c][1] = { val: dealPeek(), visible:false, hazard:false };
    // top 1 hidden: at column 1
    py[1][2] = { val: dealPeek(), visible:false, hazard:false };
    const hand=[];
    // draw 4
    hand.push(...state.draw(4));
    state.players.push({ id:p, human:cfg.humans.includes(p), hand, pyramid:py });
  }
  // core card
  state.core.card = state.core.card ?? state.draw(1)[0];

  S.state = state;
  refreshUI();
  updateHUD();
  log('üÜï New game started');
}

// Exposure logic with Hazard Lock
function exposedPositions(pl){
  const s = pl.pyramid, out=[];
  // bottom row always structurally exposed
  for(const c of [0,1,2]) if(s[c][0]) out.push([c,0]);
  // middle exposed if both supports below are empty (None)
  if(s[0][1]){
    const a = s[0][0], b = s[1][0];
    if(a===null && b===null) out.push([0,1]);
  }
  if(s[1][1]){
    const a = s[1][0], b = s[2][0];
    if(a===null && b===null) out.push([1,1]);
  }
  // top (1,2) exposed if (0,1) and (1,1) are empty
  if(s[1][2]){
    const a = s[0][1], b=s[1][1];
    if(a===null && b===null) out.push([1,2]);
  }
  return out;
}
function isExposed(pl, col, lvl){
  return exposedPositions(pl).some(([c,l])=>c===col&&l===lvl);
}

// Attempt resolution (base + optional helper)
function attemptPlay(baseCard, targetVal, helperCard=null){
  if(targetVal===JOKER || baseCard===JOKER) return { ok:true, mode:'wild' };
  if(baseCard===targetVal) return { ok:true, mode:'exact' };
  if(helperCard==null) return { ok:false };
  if(helperCard===JOKER) return { ok:true, mode:'helper-wild' }; // can force match
  // ¬± helper
  if(baseCard + helperCard === targetVal) return { ok:true, mode:'plus' };
  if(baseCard - helperCard === targetVal) return { ok:true, mode:'minus' };
  return { ok:false };
}

function cascadePathNext(col,lvl){
  if(col===0){ return (lvl===0)? [0,1] : null; }
  if(col===2){ return null; }
  // col 1
  if(lvl===0) return [1,1];
  if(lvl===1) return [1,2];
  return null;
}

// Check Core exposure (variant: bottom row cleared by any player)
function checkCoreExposure(){
  const st=S.state;
  if(st.core.exposed || st.core.cleared) return;
  for(const pl of st.players){
    const bottomCleared = [0,1,2].every(c=>pl.pyramid[c][0]===null);
    if(bottomCleared){
      st.core.exposed = true; st.core.revealed = true;
      log('üü¶ Core exposed!');
      if(st.core.card===JOKER){
        st.discard.push(st.core.card); st.core.card=null; st.core.cleared=true;
        st.over=true; st.winner='team';
        log('üèÜ Core was a Joker ‚Äì auto-clear! Team wins.');
      }
      return;
    }
  }
}

// Royal effects
function applyRoyal(val, activeIdx){
  const st=S.state;
  const me = st.players[activeIdx];
  if(val===JACK){ // swap with chosen neighbor (simplify: always right)
    const nei = st.players[(activeIdx+1)%4];
    if(me.hand.length){
      // give least-useful (not matching any of my exposed)
      const ex = new Set(exposedPositions(me).map(([c,l])=>me.pyramid[c][l]?.val));
      me.hand.sort((a,b)=>{
        const ua = a===JOKER?2:ex.has(a)?1:0;
        const ub = b===JOKER?2:ex.has(b)?1:0;
        return ua-ub;
      });
      const give = me.hand.shift();
      if(nei.hand.length<4) nei.hand.push(give); else me.hand.push(give);
    }
    if(nei.hand.length && me.hand.length<4){
      me.hand.push(nei.hand.pop());
    }
    log(`‚ôüÔ∏è Jack swap between ${seatName(me.id)} and ${seatName(nei.id)}`);
  }
  if(val===QUEEN){ // reveal one hidden (prefer my own)
    const order=[[0,1],[1,1],[1,2]];
    let done=false;
    for(const [c,l] of order){
      const s=me.pyramid[c][l];
      if(s && !s.visible){ s.visible=true; done=true; break; }
    }
    if(!done){
      // reveal a teammate hidden if found; else reveal core if hidden
      for(const p of [1,2,3].map(d=>S.state.players[(me.id+d)%4])){
        for(const [c,l] of order){
          const s=p.pyramid[c][l]; if(s && !s.visible){ s.visible=true; done=true; break; }
        }
        if(done) break;
      }
    }
    if(!done && !st.core.revealed){ st.core.revealed=true; }
    log(`üëë Queen reveal`);
  }
  if(val===KING){ // surge: draw 2 to cap 4
    while(me.hand.length<4 && S.state.deck.length>0){
      const c = st.draw(1)[0]; if(c==null) break; me.hand.push(c);
    }
    log(`üëë King surge (+cards)`);
  }
}

function doTurn_Play(baseIdx, target){
  const st=S.state;
  if(st.over) return;
  const player = st.players[st.current];

  // Build helper if chosen and valid
  let helperCard = null;
  let helperSeat = acrossOf(player.id);
  const helpersOn = S.cfg.helpersOn;
  const helperAllowed = helpersOn && st.pendingHelper && st.pendingHelper.seat===helperSeat;
  if(helperAllowed) helperCard = st.pendingHelper.card;

  // Resolve target
  if(target.kind==='core'){
    const tVal = st.core.card;
    const base = player.hand.splice(baseIdx,1)[0];
    st.discard.push(base);
    let ok = false, mode='';

    if(tVal===JOKER || base===JOKER){ ok=true; mode='wild'; }
    else if(helperCard!=null){
      if(helperCard===JOKER){ ok=true; mode='helper-wild'; }
      else if(base===tVal || base+helperCard===tVal || base-helperCard===tVal){ ok=true; mode='helper'; }
    }else if(base===tVal){ ok=true; mode='exact'; }

    if(ok){
      st.discard.push(tVal);
      st.core.card=null; st.core.cleared=true; st.over=true; st.winner='team';
      log(`üéØ ${seatName(player.id)} cleared the Core (${mode}). üèÜ Team wins!`);
    }else{
      log(`‚ùå Missed Core (${vName(base)} vs ${vName(tVal)})`);
      onFailAddHazard(player);
    }
    endOfAttemptDraw(player);
    st.selectedHandCard=null; st.selectedTarget=null; st.pendingHelper=null;
    return;
  }

  // Pyramid target
  const [col,lvl] = target.where;
  const slot = player.pyramid[col][lvl];
  const tVal = slot.val;
  const base = player.hand.splice(baseIdx,1)[0];
  st.discard.push(base);

  const res = attemptPlay(base, tVal, helperCard);
  if(res.ok){
    // clear + cascade (max 3)
    let clears=0, cur=[col,lvl];
    while(clears<3 && cur){
      const [c,l]=cur;
      const here = player.pyramid[c][l];
      // must still be exposed
      if(!here || !isExposed(player,c,l)) break;

      // does same base still match next target? (For cascade we reuse same resolution rules but without helper)
      const val = here.val;
      const okCascade = (val===JOKER || base===JOKER || base===val);
      if(!okCascade) break;

      // clear it
      player.pyramid[c][l] = null;
      st.discard.push(val);
      clears++;
      if(val>=JACK) applyRoyal(val, player.id);

      // exposure check variant (bottom row clear may expose core)
      checkCoreExposure();
      if(st.over) break;

      // next in column
      cur = cascadePathNext(c,l);
    }
    log(`‚úÖ ${seatName(player.id)} cleared ${clears} card(s)`);
  }else{
    log(`‚ùå ${seatName(player.id)} failed on ${vName(tVal)} (base ${vName(base)}${helperCard!=null?` + helper ${vName(helperCard)}`:''})`);
    onFailAddHazard(player);
  }

  endOfAttemptDraw(player);
  st.selectedHandCard=null; st.selectedTarget=null; st.pendingHelper=null;
}

function endOfAttemptDraw(player){
  const st=S.state;
  const bite = S.cfg.hazardBite;
  // If hand ever hits 0, draw back to 4 immediately
  if(player.hand.length===0){
    const drawn = st.draw(4);
    player.hand.push(...drawn);
  }else{
    if(!bite && player.hand.length<4){
      const c=st.draw(1)[0]; if(c!=null) player.hand.push(c);
    }
  }
}

function onFailAddHazard(player){
  const st=S.state;
  const c = st.draw(1)[0];
  if(c==null){ st.over=true; st.winner='bomb'; log('üí• Deck exhausted. Bomb detonates.'); return; }
  const order=[[0,0],[1,0],[2,0],[0,1],[1,1],[1,2]];
  for(const [x,y] of order){
    if(player.pyramid[x][y]===null){
      player.pyramid[x][y] = { val:c, visible:true, hazard:true };
      break;
    }
  }
}

function aiStep(){
  const st=S.state; if(st.over) return;
  const me = st.players[st.current];
  if(me.human) return;

  // Find exposed targets in my pyramid + core if exposed
  let opts = exposedPositions(me).map(([c,l])=>({kind:'pyr', where:[c,l], t:me.pyramid[c][l].val}));
  if(st.core.exposed && st.core.card!=null) opts.unshift({kind:'core', where:null, t:st.core.card});

  // Try exact matches first
  let baseIdx=-1, target=null, helper=null;

  // Exact to core first
  if(st.core.exposed && st.core.card!=null){
    const t=st.core.card;
    const idx = me.hand.findIndex(v=>v===t || v===JOKER);
    if(idx>=0){ baseIdx=idx; target={kind:'core'}; }
  }
  // Exact to hazards / low level
  if(baseIdx<0){
    for(const o of opts){
      const idx = me.hand.findIndex(v=>v===o.t || v===JOKER);
      if(idx>=0){ baseIdx=idx; target=o; break; }
    }
  }
  // Try helper with across seat if needed
  if(baseIdx<0 && S.cfg.helpersOn){
    const opp = st.players[acrossOf(me.id)];
    // attempt base + helper (prefer not to burn joker if avoidable)
    for(const o of opts){
      for(let i=0;i<me.hand.length;i++){
        const b=me.hand[i];
        // search helper that solves
        const pool = opp.human ? opp.hand /* AI can peek their opp for efficiency */ : opp.hand;
        for(let j=0;j<pool.length;j++){
          const h=pool[j];
          const ok = attemptPlay(b, o.t, h).ok;
          if(ok){
            baseIdx=i; target=o;
            // mark helper selection
            st.pendingHelper = { seat: opp.id, card:h, index:j };
            break;
          }
        }
        if(baseIdx>=0) break;
      }
      if(baseIdx>=0) break;
    }
  }

  // If still nothing, play a random exposed (will likely fail) with a random base
  if(baseIdx<0){
    if(opts.length===0){ // nothing exposed? draw 1 and end
      endOfAttemptDraw(me); return;
    }
    target = opts[0];
    baseIdx = 0;
  }

  // If helper planned and the across seat is AI, consume it
  if(st.pendingHelper && !st.players[st.pendingHelper.seat].human){
    const opp = st.players[st.pendingHelper.seat];
    opp.hand.splice(st.pendingHelper.index,1); // consume helper
  }

  doTurn_Play(baseIdx, target);
}

function nextTurn(){
  const st=S.state; if(st.over) return;
  // win/loss check after any action
  if(st.core.cleared){ st.over=true; st.winner='team'; }

  // deck-out: handled during draw
  if(st.over) return;

  // Advance seat
  st.current = (st.current+1) & 3;
  st.turn++;
  // Check core exposure variant (bottom row)
  checkCoreExposure();
}

function endTurn(){
  const st=S.state; if(st.over) return;
  // if human selected helper but never used, clear it
  st.selectedHandCard=null; st.selectedTarget=null; st.pendingHelper=null;
  nextTurn();
  refreshUI();
  if(!S.state.players[S.state.current].human) {
    // Let AI take its whole attempt, then auto-end turn
    aiStep(); updateHUD(); refreshUI();
    if(!st.over){ nextTurn(); refreshUI(); }
  }
  updateHUD();
}

function onTapHand(seatIdx, handIdx){
  const st=S.state;
  if(st.over) return;
  if(seatIdx!==st.current) return toast("Not your turn");
  st.selectedHandCard = handIdx;
  refreshUI();
}

function onTapTarget(seatIdx, col, lvl){
  const st=S.state;
  if(st.over) return;
  if(seatIdx!==st.current) return toast("Target your own pyramid");
  if(st.selectedHandCard==null) return toast("Select a hand card first");
  if(!isExposed(st.players[seatIdx], col, lvl)) return toast("That card isn't exposed");
  st.selectedTarget = { kind:'pyr', where:[col,lvl] };
  // If helper joker was preselected, nothing else to pick; human helper consumed when play occurs.
  refreshUI();
}

function onTapCore(){
  const st=S.state;
  if(st.over) return;
  if(!st.core.exposed || st.core.card==null) return;
  if(st.selectedHandCard==null) return toast("Select a hand card first");
  st.selectedTarget = { kind:'core' };
  refreshUI();
}

function onSelectHelper(){
  const st=S.state; if(st.over) return;
  const me = st.players[st.current];
  const opp = st.players[acrossOf(me.id)];
  if(!S.cfg.helpersOn) return toast("Helpers disabled");
  if(!opp.human) return toast("Across seat is AI (auto-uses helper)");
  // If a helper is already staged, clear it
  if(st.pendingHelper){ st.pendingHelper=null; refreshUI(); return; }
  // Prompt: pick one helper from across seat's hand
  // Minimal UI: take the first helper that would create a match; else select any for ¬± choice later
  if(st.selectedTarget==null){ toast("Pick a target first"); return; }
  const tVal = st.selectedTarget.kind==='core' ? st.core.card : me.pyramid[st.selectedTarget.where[0]][st.selectedTarget.where[1]].val;
  const base = me.hand[st.selectedHandCard];
  // try to find a concrete helper
  let pick = opp.hand.findIndex(h=>attemptPlay(base,tVal,h).ok);
  if(pick<0 && opp.hand.length>0) pick=0;
  if(pick<0) return toast("Helper has no cards");
  st.pendingHelper = { seat: opp.id, card: opp.hand[pick], index: pick };
  refreshUI();
}

function playNow(){
  const st=S.state;
  if(st.over) return;
  const me = st.players[st.current];
  if(st.selectedHandCard==null || st.selectedTarget==null) return toast("Pick a hand card, then a target");
  // If human across helper queued, consume it now
  if(st.pendingHelper && st.players[st.pendingHelper.seat].human){
    const opp = st.players[st.pendingHelper.seat];
    opp.hand.splice(st.pendingHelper.index,1);
  }
  doTurn_Play(st.selectedHandCard, st.selectedTarget);
  updateHUD(); refreshUI();
}

function updateHUD(){
  const st=S.state;
  gid('turnInfo').textContent = `Turn: ${st.turn} ‚Ä¢ Active: ${seatName(st.current)}`;
  gid('deckInfo').textContent = `Deck: ${st.deck.length} ‚Ä¢ Discard: ${st.discard.length} ‚Ä¢ Reshuffles: ${st.reshuffles}`;
  gid('coreInfo').textContent = st.core.cleared ? 'Core: CLEARED' : (st.core.exposed ? `Core: ${st.core.card===null?'CLEARED':vName(st.core.card)}` : 'Core: hidden');
  if(st.over){
    toast(st.winner==='team' ? 'üèÜ Team wins!' : 'üí• Bomb detonated');
  }
  gid('endTurnBtn').disabled = st.over;
}

// ---------- UI RENDER ----------
function renderSeat(pl){
  const st=S.state;
  const meTurn = st.current===pl.id;
  const isMe = pl.id===0;
  const seat = document.createElement('div');
  seat.className='seat'+(isMe?' me':'');
  seat.innerHTML = `
    <div class="head">
      <div class="name">${seatName(pl.id)} ${pl.human? '‚Ä¢ Human' : '‚Ä¢ AI'}</div>
      <div class="meta">Hand: ${pl.human? pl.hand.map(v=>vName(v)).join(' ') : 'üÇ†'.repeat(pl.hand.length)}</div>
    </div>
    <div class="pyramid"></div>
    <div class="flex">
      <div class="hand grow"></div>
      ${meTurn? `<button class="btn" id="helperBtn${pl.id}">Across Helper</button>`:''}
      ${meTurn? `<button class="btn btn-primary" id="playBtn${pl.id}">Play</button>`:''}
    </div>
  `;
  const pyr = seat.querySelector('.pyramid');
  // build rows: bottom (3), middle (2 at col 0&1), top (1 at col 1)
  const r3 = document.createElement('div'); r3.className='row3';
  const r2 = document.createElement('div'); r2.className='row2';
  const r1 = document.createElement('div'); r1.className='row1';

  for(const c of [0,1,2]) r3.appendChild(renderSlot(pl,c,0));
  for(const c of [0,1]) r2.appendChild(renderSlot(pl,c,1));
  r1.appendChild(renderSlot(pl,1,2));

  pyr.appendChild(r3); pyr.appendChild(r2); pyr.appendChild(r1);

  // hand chips (show face for humans only)
  const handDiv = seat.querySelector('.hand');
  pl.hand.forEach((v,i)=>{
    const chip=document.createElement('button');
    chip.className='chip'+(st.selectedHandCard===i && meTurn?' sel':'');
    chip.textContent = pl.human? vName(v) : 'üÇ†';
    chip.disabled = !meTurn || !pl.human;
    chip.onclick = ()=> onTapHand(pl.id, i);
    handDiv.appendChild(chip);
  });

  if(meTurn){
    seat.querySelector(`#playBtn${pl.id}`).onclick = playNow;
    seat.querySelector(`#helperBtn${pl.id}`).onclick = onSelectHelper;
  }

  return seat;
}
function renderSlot(pl,col,lvl){
  const st=S.state;
  const s = pl.pyramid[col][lvl];
  const el = document.createElement('button');
  el.className='card';
  if(s===null){ el.classList.add('hidden'); el.textContent='¬∑'; el.disabled=true; return el; }
  const exposed = isExposed(pl,col,lvl);
  if(s.hazard) el.classList.add('hazard');
  if(!s.visible) el.classList.add('hidden');
  if(exposed) el.classList.add('exposed');
  el.textContent = s.visible ? vName(s.val) : '‚ñ†';
  el.disabled = !(st.current===pl.id && exposed);
  el.onclick = ()=> onTapTarget(pl.id,col,lvl);
  return el;
}

function renderCore(){
  const st=S.state;
  const wrap = document.createElement('div');
  wrap.className='seat';
  wrap.innerHTML = `
    <div class="head"><div class="name">Core</div><div class="meta">${st.core.exposed? 'Exposed' : 'Hidden'}</div></div>
    <div class="stack" id="coreStack"></div>
    <div class="status">${st.core.cleared? 'CLEARED' : 'Target when exposed'}</div>
  `;
  const stack = wrap.querySelector('#coreStack');
  const btn = document.createElement('button');
  btn.className='card core';
  btn.textContent = st.core.cleared? '‚úì' : (st.core.exposed ? vName(st.core.card) : '‚ñ†');
  btn.disabled = !(st.core.exposed && !st.core.cleared && S.state.current===0 && S.state.players[0].human);
  btn.onclick = onTapCore;
  stack.appendChild(btn);
  return wrap;
}

function refreshUI(){
  const st=S.state, board=gid('board');
  board.innerHTML='';
  // Render seats in 2√ó2, with core panel as a 5th block when narrow view: we‚Äôll append core at the end
  // Grid order: P0, P1, P2, P3
  for(let i=0;i<4;i++) board.appendChild(renderSeat(st.players[i]));
  // Append a compact Core tile
  board.appendChild(renderCore());

  // Status blip
  const sel = st.selectedHandCard!=null? `Hand: ${vName(st.players[st.current].hand[st.selectedHandCard])}` : 'Hand: ‚Äî';
  const tgt = st.selectedTarget? (st.selectedTarget.kind==='core'?'Core':`(${st.selectedTarget.where[0]},${st.selectedTarget.where[1]})`) : 'Target: ‚Äî';
  const help = st.pendingHelper? `Helper: ${seatName(st.pendingHelper.seat)} ${vName(st.pendingHelper.card)}` : 'Helper: ‚Äî';
  gid('status').textContent = `${sel} ‚Ä¢ ${tgt} ‚Ä¢ ${help}`;
}

// ---------- Controls ----------
gid('newGameBtn').onclick = ()=>{
  const humans = Array.from(document.querySelectorAll('.seatpick')).filter(x=>x.checked).map(x=>+x.dataset.seat);
  S.cfg = {
    humans: humans,
    helpersOn: gid('helpersOn').checked,
    hazardBite: gid('hazardBite').checked,
    twoReshuffles: gid('twoReshuffles').checked
  };
  newGame(S.cfg);
  // After new game, if current is AI, let AI run its attempt then auto-advance
  if(!S.state.players[S.state.current].human){ aiStep(); updateHUD(); refreshUI(); nextTurn(); refreshUI(); updateHUD(); }
};
gid('quickStartBtn').onclick = ()=>{
  // Solo vs 3 AI (you are P0)
  S.cfg = { humans:[0], helpersOn:true, hazardBite:false, twoReshuffles:false };
  // reflect toggles in UI
  document.querySelectorAll('.seatpick').forEach((x,i)=>x.checked = (i===0));
  gid('helpersOn').checked = true; gid('hazardBite').checked=false; gid('twoReshuffles').checked=false;
  newGame(S.cfg);
};
gid('endTurnBtn').onclick = ()=>{ endTurn(); };

// First load
S.cfg = { humans:[0], helpersOn:true, hazardBite:false, twoReshuffles:false };
newGame(S.cfg);
</script>
</body>
</html>