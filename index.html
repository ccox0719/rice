<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bomb Diffusal â€“ Pyramid (Minimal)</title>
<style>
  :root{
    --bg:#0b0f19; --panel:#121826; --ink:#e6ebff; --muted:#9fb1ff;
    --accent:#5aa9ff; --danger:#ff6b6b; --ok:#17c964; --card:#0f1523; --line:#1c2542;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:10px 14px;border-bottom:1px solid var(--line)}
  h1{margin:0 0 6px;font-size:18px}
  #top{display:flex;gap:12px;flex-wrap:wrap;font-size:13px;color:var(--muted)}
  main{display:grid;grid-template-columns:1fr 320px;gap:12px;padding:12px}
  @media (max-width: 1000px){ main{grid-template-columns:1fr} aside{order:-1} }

  .zone{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:10px}
  #table{display:grid;gap:10px}
  .players{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:10px}
  @media (max-width: 720px){ .players{grid-template-columns:1fr} }

  .player{border:1px solid var(--line);border-radius:10px;padding:10px}
  .player.active{outline:2px solid var(--accent)}
  .ph{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .ph .name{font-weight:700;color:#c6d4ff}
  .tag{font-size:12px;background:#0f1730;border:1px solid #2a3a6a;border-radius:999px;padding:2px 6px;color:#c0d3ff}

  .hand{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .staging{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}

  .pyramid{display:grid;gap:5px;margin-top:8px}
  .row{display:flex;gap:6px;justify-content:center}
  .slot{width:42px;height:56px;border:1px dashed #2a3a6a;border-radius:8px;display:flex;align-items:center;justify-content:center}
  .card{
    display:flex;align-items:center;justify-content:center;
    min-width:42px;height:56px;border-radius:8px;border:1px solid #2b3e7d;
    background:linear-gradient(180deg,#0f1830,#0c1326);font-weight:700;user-select:none;
  }
  .card.joker{border-color:#ffd86b;box-shadow:inset 0 0 0 1px #ffd86b}
  .hidden{opacity:.5;filter:grayscale(.7)}
  .haz{background:#2b0f12;border-color:#6a2330}
  .exposed{outline:2px solid rgba(90,169,255,.55)}
  .click{cursor:pointer}
  .sel{outline:2px solid var(--accent)}

  button{background:#142044;border:1px solid #2a3a6a;color:var(--ink);padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  button.primary{background:var(--accent);color:#001332;border:none}
  button:disabled{opacity:.45;cursor:not-allowed}
  .rowbtns{display:flex;gap:6px;flex-wrap:wrap}
  .mini{font-size:12px;color:var(--muted);margin-top:6px}

  #lastplay{font-size:13px;line-height:1.35;background:#0e1322;border:1px solid var(--line);border-radius:8px;padding:8px;min-height:44px}
  #controls .rowbtns{margin-bottom:8px}
</style>
</head>
<body>
<header>
  <h1>Bomb Diffusal â€“ Pyramid (Minimal)</h1>
  <div id="top">
    <span id="turn">Turn: â€“</span>
    <span id="deck">Deck: â€“</span>
    <span id="reshuffles">Reshuffles left: â€“</span>
  </div>
</header>

<main>
  <section id="table" class="zone">
    <div id="coreArea" class="zone" style="margin-bottom:8px;display:flex;align-items:center;justify-content:center;gap:10px">
      <strong>Core:</strong>
      <div id="coreSlot" class="slot"></div>
      <span class="mini" id="coreTip">Exposed when all players clear their top card.</span>
    </div>

    <div class="players" id="players"></div>
  </section>

  <aside class="zone">
    <div id="controls">
      <div class="rowbtns">
        <button id="newBtn" class="primary">New Game</button>
        <button id="endBtn" disabled>End Turn</button>
      </div>
      <div class="rowbtns">
        <button id="playBaseBtn" disabled>Play Base</button>
        <button id="helpLBtn" disabled>Left Helper</button>
        <button id="helpRBtn" disabled>Right Helper</button>
        <button id="resolveBtn" disabled>Resolve</button>
        <button id="cancelBtn" disabled>Cancel Attempt</button>
      </div>
      <div class="mini">
        Select a **base** (active player), optional **left/right** helpers (neighbors), then **Resolve**.<br/>
        Target by clicking an **exposed** card in your pyramid (or Core if exposed).
      </div>
    </div>

    <h3 style="margin:10px 0 6px">Last Play</h3>
    <div id="lastplay">â€“</div>
  </aside>
</main>

<script>
/*** Minimal bomb-pyramid engine ***/
const SUITS = ["â™£","â™¦","â™¥","â™ "];
const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const JOKERS = 2;

const UI = {
  playersEl: document.getElementById('players'),
  coreSlot: document.getElementById('coreSlot'),
  turn: document.getElementById('turn'),
  deck: document.getElementById('deck'),
  resh: document.getElementById('reshuffles'),
  last: document.getElementById('lastplay'),

  newBtn: document.getElementById('newBtn'),
  endBtn: document.getElementById('endBtn'),
  playBaseBtn: document.getElementById('playBaseBtn'),
  helpLBtn: document.getElementById('helpLBtn'),
  helpRBtn: document.getElementById('helpRBtn'),
  resolveBtn: document.getElementById('resolveBtn'),
  cancelBtn: document.getElementById('cancelBtn'),
};

const S = {
  players: [],     // 4 players
  deck: [],
  discard: [],
  reshuffles: 1,
  turn: 0,
  started: false,

  // attempt state
  base: null, helpers: {L:null, R:null}, target: null, // target: {who:'p'|'core', seat?, row?, col?}
};

function newCard(s,r){ return {s,r}; }
function isJoker(c){ return c && c.s==="â˜…" && c.r==="Joker"; }
function label(c){ return isJoker(c) ? "Joker" : `${c.r}${c.s}`; }
function val(r){
  if(r==="A") return 1;
  if(r==="J") return 11;
  if(r==="Q") return 12;
  if(r==="K") return 13;
  const n = Number(r); return Number.isFinite(n) ? n : null;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function buildDeck(){
  const d=[];
  for(const s of SUITS) for(const r of RANKS) d.push(newCard(s,r));
  for(let i=0;i<JOKERS;i++) d.push({s:"â˜…", r:"Joker"});
  return shuffle(d);
}

function deal(){
  S.deck = buildDeck();
  S.discard = [];
  S.reshuffles = 1;
  S.turn = 0;
  S.started = true;

  // players
  S.players = Array.from({length:4}, (_,i)=>({
    seat:i,
    name:`P${i+1}`,
    hand:[],
    // pyramid rows: r0=3 (face-up), r1=2 (hidden), r2=1 (hidden)
    rows:[ [null,null,null], [null,null], [null] ],
    coreCleared:false,
  }));

  // build pyramids
  for(const p of S.players){
    // bottom row face-up
    for(let c=0;c<3;c++){
      p.rows[0][c] = {card: draw(), hidden:false, hazard:false};
    }
    // middle hidden
    for(let c=0;c<2;c++){
      p.rows[1][c] = {card: draw(), hidden:true, hazard:false};
    }
    // top hidden
    p.rows[2][0] = {card: draw(), hidden:true, hazard:false};
  }

  // shared core (hidden)
  S.core = {card: draw(), hidden:true};

  // hands (5 each)
  for(let i=0;i<4;i++) drawTo(i,5);

  resetAttempt();
  render();
}

function draw(){
  if(S.deck.length===0){
    if(S.reshuffles>0){
      S.deck = shuffle(S.discard);
      S.discard = [];
      S.reshuffles--;
      renderBars();
    }else{
      endGame(false, "Deck exhausted after the single reshuffle.");
      return null;
    }
  }
  return S.deck.pop();
}
function drawTo(seat, n=1){
  const P = S.players[seat];
  for(let i=0;i<n;i++){
    const c = draw(); if(!c) return;
    P.hand.push(c);
  }
}
function ensureRefillIfEmpty(seat){
  const P = S.players[seat];
  if(P.hand.length===0){
    const want = Math.min(5, S.deck.length + S.discard.length + (S.reshuffles?999:0));
    while(P.hand.length<5){
      const c = draw(); if(!c) break;
      P.hand.push(c);
    }
  }
}

function exposedCells(p){
  // returns list of {row,col,cell} exposed (not hidden & not blocked by above-lock rule)
  const ex=[];
  const R=p.rows;
  // bottom row always exposed if exists
  for(let c=0;c<3;c++){ const cell=R[0][c]; if(cell){ ex.push({row:0,col:c,cell}); } }
  // row1: exposed if both beneath are empty
  for(let c=0;c<2;c++){
    const belowL=R[0][c], belowR=R[0][c+1];
    const cell=R[1][c];
    if(cell && !belowL && !belowR && !cell.hidden){ ex.push({row:1,col:c,cell}); }
  }
  // row2: exposed if row1 cleared
  if(R[2][0] && R[1].every(x=>!x) && !R[2][0].hidden) ex.push({row:2,col:0,cell:R[2][0]});
  return ex;
}
function revealIfExposed(p){
  const R=p.rows;
  // flip row1 when supports cleared
  for(let c=0;c<2;c++){
    const belowL=R[0][c], belowR=R[0][c+1];
    if(!belowL && !belowR && R[1][c] && R[1][c].hidden && !isLockedByHazardBelow(p,1,c)){
      R[1][c].hidden=false;
    }
  }
  // flip row2 when row1 cleared
  if(R[1].every(x=>!x) && R[2][0] && R[2][0].hidden && !isLockedByHazardBelow(p,2,0)){
    R[2][0].hidden=false;
  }
  // core exposure rule: exposed when ALL players have cleared their top row (row2)
  if(S.players.every(pp=>!pp.rows[2][0])) S.core.hidden=false;
}
function isLockedByHazardBelow(p, row, col){
  // Hazard Lock: any card above a hazard stays hidden until that hazard is cleared
  // If row1 cell, check any bottom hazard beneath; if row2, check row1 presence/hazard
  if(row===1){
    const hazards = [p.rows[0][col], p.rows[0][col+1]].filter(Boolean).some(c=>c.hazard);
    return hazards;
  }
  if(row===2){
    const anyHazRow1 = p.rows[1].filter(Boolean).some(c=>c.hazard);
    return anyHazRow1;
  }
  return false;
}

function clearCell(p,row,col){
  if(!p.rows[row][col]) return;
  // if the cleared card is a Joker target â†’ just remove it; logic same
  const card = p.rows[row][col].card;
  // discard cleared card
  S.discard.push(card);
  p.rows[row][col]=null;
  revealIfExposed(p);
}

function resetAttempt(){
  S.base = null; S.helpers={L:null,R:null}; S.target=null;
  UI.playBaseBtn.disabled = true;
  UI.helpLBtn.disabled = true;
  UI.helpRBtn.disabled = true;
  UI.resolveBtn.disabled = true;
  UI.cancelBtn.disabled = true;
}

function seatLeftOf(seat){ return (seat+3)%4; }
function seatRightOf(seat){ return (seat+1)%4; }

/*** Matching logic ***/
function numeric(c){
  if(!c) return null;
  if(isJoker(c)) return "J"; // special marker
  const v = val(c.r);
  return v ?? null; // faces are null
}
function targetValue(t){
  if(t.who==="core"){
    return isJoker(S.core.card) ? "J" : val(S.core.card.r);
  }else{
    const cell = S.players[t.seat].rows[t.row][t.col];
    return isJoker(cell.card) ? "J" : val(cell.card.r);
  }
}
function attemptMatches(){
  if(!S.base || !S.target) return false;
  const tv = targetValue(S.target);
  if(tv==="J") return true; // Joker target auto-clears
  const b = numeric(S.base);
  if(b==="J") return true;  // Joker base auto-match
  if(b==null) return false; // faces have no numeric value

  const l = S.helpers.L ? numeric(S.helpers.L) : null;
  const r = S.helpers.R ? numeric(S.helpers.R) : null;

  // any helper joker makes it auto
  if(l==="J" || r==="J") return true;

  // Base = Target
  if(b===tv) return true;

  // Base Â± helper = Target
  if(l!=null && (b+l===tv || b-l===tv)) return true;
  if(r!=null && (b+r===tv || b-r===tv)) return true;

  // Base Â± helper1 Â± helper2 = Target (all combos)
  if(l!=null && r!=null){
    if(b+l+r===tv) return true;
    if(b+l-r===tv) return true;
    if(b-l+r===tv) return true;
    if(b-l-r===tv) return true;
  }
  return false;
}

function applyCascadeAndClear(){
  let clears = 0;
  for(let step=0; step<3; step++){
    if(!attemptMatches()) break;

    // clear target
    if(S.target.who==="core"){
      S.discard.push(S.core.card);
      S.core = {card:null, hidden:false};
      clears++;
      break; // core cleared ends it
    }else{
      const P = S.players[S.target.seat];
      clearCell(P, S.target.row, S.target.col);
      clears++;
      // try to retarget automatically to a NEWLY exposed card on same player's pyramid (prefers higher rows)
      const expo = exposedCells(S.players[S.turn]);
      if(expo.length){
        // pick first exposed (topmost priority)
        expo.sort((a,b)=>a.row-b.row).reverse(); // prefer higher row
        S.target = {who:"p", seat:S.turn, row:expo[0].row, col:expo[0].col};
        continue;
      }else if(!S.core.hidden){
        S.target = {who:"core"};
        continue;
      }else{
        break;
      }
    }
  }
  return clears;
}

/*** Hazard handling ***/
function addHazardToActive(){
  const P = S.players[S.turn];
  // place face-up to the lowest available slot (bottom â†’ middle â†’ top)
  const order = [
    {row:0,col:0},{row:0,col:1},{row:0,col:2},
    {row:1,col:0},{row:1,col:1},
    {row:2,col:0}
  ];
  for(const pos of order){
    if(!P.rows[pos.row][pos.col]){
      const c = draw(); if(!c) return;
      P.rows[pos.row][pos.col] = {card:c, hidden:false, hazard:true};
      // Hazard Lock: anything above remains/turns hidden; we enforce on revealIfExposed
      return;
    }
  }
  // no room â†’ (theoretically should not happen since we always fill empty slots) â€” treat as fail-safe
}

/*** Turn flow ***/
function passTurn(){
  // active draws 1 after attempt (success or fail)
  drawTo(S.turn,1);

  // any helper who hit 0 already refilled during selection; also check all players
  for(let i=0;i<4;i++){ ensureRefillIfEmpty(i); }

  // win/lose checks
  if(!S.core.card){ endGame(true, "Core cleared! You win!"); return; }
  if(!S.started) return; // ended due to deck loss

  // next
  S.turn = (S.turn+1)%4;
  resetAttempt();
  render();
}

function endGame(win, msg){
  S.started=false;
  UI.endBtn.disabled = true;
  UI.playBaseBtn.disabled = true;
  UI.helpLBtn.disabled = true;
  UI.helpRBtn.disabled = true;
  UI.resolveBtn.disabled = true;
  UI.cancelBtn.disabled = true;
  UI.last.textContent = (win? "ðŸ† " : "ðŸ’¥ ") + msg;
}

/*** UI selection & actions ***/
let selectedCard = null; // {seat, idx, kind:'hand'}
function selectCard(seat, idx){
  if(!S.started) return;
  selectedCard = {seat, idx, kind:'hand'};
  render(); // to show selection outline
}
function selectTarget(seatRowColOrCore){
  if(!S.started) return;
  // Only active player can set target; target must be exposed in their pyramid or the core (if exposed)
  if(seatRowColOrCore === 'core'){
    if(S.core.hidden) return;
    S.target = {who:"core"};
  }else{
    const {seat,row,col} = seatRowColOrCore;
    if(seat!==S.turn) return;
    const cell = S.players[seat].rows[row][col];
    if(!cell || cell.hidden) return;
    S.target = {who:"p", seat,row,col};
  }
  render();
}

function playBase(){
  if(!selectedCard) return;
  if(selectedCard.seat !== S.turn) return; // base must be active player's card
  const P = S.players[S.turn];
  S.base = P.hand.splice(selectedCard.idx,1)[0];
  selectedCard = null;
  // enable helpers if neighbors
  UI.helpLBtn.disabled = false;
  UI.helpRBtn.disabled = false;
  UI.resolveBtn.disabled = false;
  render();
}
function playHelper(which){
  const seat = which==='L' ? seatLeftOf(S.turn) : seatRightOf(S.turn);
  if(!selectedCard || selectedCard.seat !== seat) return;
  const P = S.players[seat];
  const card = P.hand.splice(selectedCard.idx,1)[0];
  S.helpers[which] = card;
  selectedCard=null;
  ensureRefillIfEmpty(seat);
  render();
}
function cancelAttempt(){
  // return played cards (base + helpers) to respective hands (top)
  if(S.base) S.players[S.turn].hand.push(S.base);
  if(S.helpers.L){ S.players[seatLeftOf(S.turn)].hand.push(S.helpers.L); }
  if(S.helpers.R){ S.players[seatRightOf(S.turn)].hand.push(S.helpers.R); }
  resetAttempt();
  selectedCard=null;
  render();
}

function resolveAttempt(){
  if(!S.base || !S.target){ UI.last.textContent="Select a base and a target."; return; }

  const before = `${S.players[S.turn].name}: Base ${label(S.base)}`
    + (S.helpers.L? ` + L ${label(S.helpers.L)}`:"")
    + (S.helpers.R? ` + R ${label(S.helpers.R)}`:"")
    + ` â†’ Target ${S.target.who==="core" ? "Core" : `r${S.target.row+1}c${S.target.col+1}`}`;

  if(!attemptMatches()){
    // fail â†’ hazard to active, draw 1 for active (via passTurn), log last play
    addHazardToActive();
    UI.last.textContent = `âŒ ${before} â†’ Fail. Hazard added to ${S.players[S.turn].name}.`;
    // discard played (helpers used still go to discard even on fail)
    if(S.base) S.discard.push(S.base);
    if(S.helpers.L) S.discard.push(S.helpers.L);
    if(S.helpers.R) S.discard.push(S.helpers.R);
    resetAttempt();
    passTurn();
    return;
  }

  // success â†’ cascade up to 3 clears
  const clears = applyCascadeAndClear();

  // discard played cards after resolution
  if(S.base) S.discard.push(S.base);
  if(S.helpers.L) S.discard.push(S.helpers.L);
  if(S.helpers.R) S.discard.push(S.helpers.R);

  UI.last.textContent = `âœ… ${before} â†’ Cleared ${clears} card${clears===1?"":"s"}.`;
  resetAttempt();
  passTurn();
}

/*** Render ***/
function renderBars(){
  UI.turn.textContent = S.started ? `Turn: ${S.players[S.turn].name}` : "Turn: â€”";
  UI.deck.textContent = `Deck: ${S.deck.length}`;
  UI.resh.textContent = `Reshuffles left: ${S.reshuffles}`;
}
function cardNode(c, seat, idx){
  const d = document.createElement('div');
  d.className = 'card' + (isJoker(c)?' joker':'');
  d.textContent = isJoker(c) ? 'Joker' : `${c.r}${c.s}`;
  d.classList.add('click');
  if(selectedCard && selectedCard.seat===seat && selectedCard.idx===idx) d.classList.add('sel');
  d.addEventListener('click', ()=>selectCard(seat, idx));
  return d;
}
function cellNode(pidx,row,col){
  const cell = S.players[pidx].rows[row][col];
  const el = document.createElement('div');
  if(!cell){ el.className='slot'; return el; }
  const exposed = !cell.hidden;
  const d = document.createElement('div');
  d.className = 'card' + (cell.hazard?' haz':'') + (exposed?' exposed':' hidden');
  d.textContent = exposed ? (isJoker(cell.card)? 'Joker' : `${cell.card.r}${cell.card.s}`) : 'ðŸ‚ ';
  if(exposed && pidx===S.turn){
    d.classList.add('click');
    d.addEventListener('click', ()=>selectTarget({seat:pidx,row,col}));
  }
  el.appendChild(d);
  return el;
}
function renderPlayer(p){
  const box = document.createElement('div');
  box.className = 'player' + (S.turn===p.seat && S.started ? ' active':'');
  const head = document.createElement('div');
  head.className='ph';
  const nm = document.createElement('span'); nm.className='name'; nm.textContent=p.name;
  const tg = document.createElement('span'); tg.className='tag'; tg.textContent=`Hand: ${p.hand.length}`;
  head.appendChild(nm); head.appendChild(tg);
  box.appendChild(head);

  // Pyramid
  const pyr = document.createElement('div'); pyr.className='pyramid';
  const r2 = document.createElement('div'); r2.className='row'; r2.appendChild(cellNode(p.seat,2,0)); pyr.appendChild(r2);
  const r1 = document.createElement('div'); r1.className='row'; for(let c=0;c<2;c++) r1.appendChild(cellNode(p.seat,1,c)); pyr.appendChild(r1);
  const r0 = document.createElement('div'); r0.className='row'; for(let c=0;c<3;c++) r0.appendChild(cellNode(p.seat,0,c)); pyr.appendChild(r0);
  box.appendChild(pyr);

  // Hand (visible â€“ co-op)
  const hand = document.createElement('div'); hand.className='hand';
  p.hand.forEach((c,i)=>hand.appendChild(cardNode(c,p.seat,i)));
  box.appendChild(hand);

  return box;
}
function renderCore(){
  UI.coreSlot.innerHTML='';
  if(!S.core.card){
    const d=document.createElement('div'); d.className='card'; d.textContent='Cleared'; UI.coreSlot.appendChild(d); return;
  }
  const exposed = !S.core.hidden;
  const d = document.createElement('div');
  d.className = 'card' + (exposed?' exposed':' hidden') + (isJoker(S.core.card)?' joker':'');
  d.textContent = exposed ? (isJoker(S.core.card)?'Joker': `${S.core.card.r}${S.core.card.s}`) : 'ðŸ‚ ';
  if(exposed){
    d.classList.add('click');
    d.addEventListener('click', ()=>selectTarget('core'));
  }
  UI.coreSlot.appendChild(d);
}
function render(){
  renderBars();
  renderCore();

  UI.playersEl.innerHTML='';
  S.players.forEach(p=>UI.playersEl.appendChild(renderPlayer(p)));

  // enable/disable controls
  const canAct = S.started;
  UI.endBtn.disabled = !canAct;
  UI.playBaseBtn.disabled = !(canAct && selectedCard && selectedCard.seat===S.turn);
  UI.helpLBtn.disabled = !(canAct && selectedCard && selectedCard.seat===seatLeftOf(S.turn));
  UI.helpRBtn.disabled = !(canAct && selectedCard && selectedCard.seat===seatRightOf(S.turn));
  UI.resolveBtn.disabled = !(canAct && S.base && S.target);
  UI.cancelBtn.disabled = !(canAct && (S.base || S.helpers.L || S.helpers.R));

  // highlight selected
  // (handled in cardNode)
}

/*** Wire buttons ***/
UI.newBtn.addEventListener('click', deal);
UI.endBtn.addEventListener('click', ()=>{ resetAttempt(); selectedCard=null; passTurn(); });
UI.playBaseBtn.addEventListener('click', playBase);
UI.helpLBtn.addEventListener('click', ()=>playHelper('L'));
UI.helpRBtn.addEventListener('click', ()=>playHelper('R'));
UI.resolveBtn.addEventListener('click', resolveAttempt);
UI.cancelBtn.addEventListener('click', cancelAttempt);

// init
render();
</script>
</body>
</html>
