<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bomb Diffusal ‚Äî Pyramid (Lite, Last-Play Only)</title>
<style>
  :root{
    --bg:#0b0f19; --panel:#121826; --ink:#e8edff; --muted:#a8b6e8;
    --accent:#69a7ff; --line:#1b2544; --chip:#0f1730; --danger:#ff6b6b; --ok:#18c964;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0f1630,#0b0f19)}
  h1{margin:0 0 6px;font-size:18px;letter-spacing:.2px}
  .bar{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:13px}
  main{display:grid;grid-template-columns:1fr 340px;gap:12px;padding:12px}
  @media (max-width: 960px){ main{grid-template-columns:1fr} aside{order:-1} }
  .zone{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls .row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  button{background:#0f1730;color:var(--ink);border:1px solid #2a3a69;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  button.primary{background:var(--accent);border:none;color:#001b3a}
  button:disabled{opacity:.45;cursor:not-allowed}
  select{background:#0f1730;border:1px solid #2a3a69;color:var(--ink);border-radius:8px;padding:6px}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{background:#0f1730;border:1px solid #24356a;border-radius:999px;padding:2px 8px;font-size:12px;color:#cbd7ff}
  .grid{display:grid;gap:12px}
  .p1Row{display:grid;grid-template-columns:1fr;gap:12px}
  .botsRow{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width: 1100px){ .botsRow{grid-template-columns:1fr} }
  .player{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .player h2{margin:0 0 8px;font-size:14px;color:var(--muted)}
  .me{outline:2px solid rgba(105,167,255,.35)}
  .note{font-size:12px;color:var(--muted);margin-top:6px}
  .hand,.staging{display:flex;gap:6px;flex-wrap:wrap}
  .pyramid{display:grid;gap:6px}
  .py-row{display:flex;gap:6px;justify-content:center}
  .slot{width:42px;height:58px;border:1px dashed #31406f;border-radius:8px;display:flex;align-items:center;justify-content:center}
  .exposed{outline:2px solid rgba(105,167,255,.6)}
  .card{
    display:inline-flex;align-items:center;justify-content:center;
    min-width:44px;height:58px;border-radius:8px;border:1px solid #31406f;
    background:linear-gradient(180deg,#101a36,#0c1226);font-weight:700;user-select:none;padding:0 6px
  }
  .mini{min-width:36px;height:46px;font-size:13px}
  .card.s-C{color:#8ae66e} .card.s-H{color:#ff9bb3}
  .card.s-D{color:#7fd1ff} .card.s-S{color:#d0c6ff}
  .card.A{border-color:#ffd86b;box-shadow:inset 0 0 0 1px #ffd86b}
  .card.face{border-color:#ff9f6b}
  .dim{opacity:.5;filter:grayscale(.7)}
  .clickable{cursor:pointer}
  .selected{outline:2px solid var(--accent)}
  aside .zone{position:sticky;top:12px}
  #lastPlay{font-size:13px;line-height:1.35}
  #hint{min-height:18px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>Bomb Diffusal ‚Äî Pyramid (Lite, Last-Play Only)</h1>
  <div class="bar">
    <span id="turnSpan"></span>
    <span id="deckSpan"></span>
    <span id="reshuffleSpan"></span>
    <span id="coreSpan"></span>
    <span id="targetsSpan"></span>
  </div>
</header>

<main>
  <section class="grid">
    <div class="zone controls">
      <div class="row">
        <button id="newBtn" class="primary">New Game</button>
        <label>Speed:
          <select id="speedSel">
            <option value="700">Normal</option>
            <option value="350" selected>Fast</option>
            <option value="140">Turbo</option>
          </select>
        </label>
        <label><input id="autoP1" type="checkbox" /> Auto-play Player 1</label>
      </div>
      <div class="row">
        <button id="playBtn" disabled>Play Selected (Attempt)</button>
        <button id="skipBtn" disabled>Skip</button>
      </div>
      <div class="chips">
        <span class="chip">Attempt cards used: <strong id="attemptCount">0/3</strong></span>
        <span class="chip">Helpers allowed: <strong>Left & Right only</strong></span>
        <span class="chip">Loss: <strong>Deck exhausted (1 reshuffle)</strong></span>
      </div>
      <div id="hint">You‚Äôre Player 1. Select a card, then press ‚ÄúPlay Selected‚Äù. Bots will add helpers if needed.</div>
    </div>

    <!-- Player 1 always visible -->
    <div class="p1Row"><div class="player me" id="p0Box"></div></div>
    <!-- Three bot seats -->
    <div class="botsRow">
      <div class="player" id="p1Box"></div>
      <div class="player" id="p2Box"></div>
      <div class="player" id="p3Box"></div>
    </div>
  </section>

  <aside>
    <div class="zone">
      <h3 style="margin:0 0 8px">Last play</h3>
      <div id="lastPlay">‚Äî</div>
    </div>
  </aside>
</main>

<script>
/* ======= Minimal-state helpers (no long logs kept) ======= */
let ended = false;
const GL={C:"‚ô£",D:"‚ô¶",H:"‚ô•",S:"‚ô†"};
const SUITS=["C","D","H","S"];
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RVAL=r=>r==="A"?1:r==="J"?11:r==="Q"?12:r==="K"?13:+r;
const isFace=r=>r==="J"||r==="Q"||r==="K";
const label=c=>c?((c.r==="Joker")?"Joker‚òÖ":(c.r+GL[c.s])):"‚Äî";
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function makeDeck(){
  const d=[]; for(const s of SUITS)for(const r of RANKS)d.push({s,r});
  d.push({r:"Joker",s:"‚òÖ"}); d.push({r:"Joker",s:"‚òÖ"}); // two jokers
  return shuffle(d);
}

/* ======= Core state ======= */
const S={
  deck:[], discard:[],
  players:[], // {seat,name,isHuman,hand:[],pyr:{rows}}
  turn:0, speed:350, autoP1:false,
  attempt:[], contributed:new Set(), // compact chain
  reshufflesLeft:1, started:false,
  core:{card:null, exposed:false, cleared:false},
  lastPlay:"‚Äî"
};
function newPlayer(i,isHuman){return{seat:i,name:isHuman?"You":"Bot "+(i+1),isHuman,hand:[],pyr:null}}

/* ======= Pyramid build (bottom row face-up only) ======= */
function buildPyramid(D){
  const rows=[[],[],[]];
  for(let i=0;i<3;i++) rows[0].push({card:D.pop(),hidden:false,hazard:false});
  for(let i=0;i<2;i++) rows[1].push({card:D.pop(),hidden:true,hazard:false});
  rows[2].push({card:D.pop(),hidden:true,hazard:false});
  return {rows};
}
function exposedSlots(p){
  const R=p.pyr.rows, out=[];
  for(let c=0;c<3;c++) if(R[0][c] && !R[0][c].hidden) out.push({row:0,col:c});
  for(let c=0;c<2;c++){
    if(R[1][c] && !R[1][c].hidden && !R[0][c] && !R[0][c+1]) out.push({row:1,col:c});
  }
  if(R[2][0] && !R[2][0].hidden && !R[1][0] && !R[1][1]) out.push({row:2,col:0});
  return out;
}
function flipExposures(p){
  const R=p.pyr.rows;
  for(let c=0;c<2;c++){
    if(R[1][c] && R[1][c].hidden && !R[0][c] && !R[0][c+1]) R[1][c].hidden=false;
  }
  if(R[2][0] && R[2][0].hidden && !R[1][0] && !R[1][1]) R[2][0].hidden=false;
}

/* ======= Deal & flow ======= */
function startGame(){
  ended=false; S.started=true; S.reshufflesLeft=1; S.lastPlay="‚Äî";
  S.deck=makeDeck(); S.discard.length=0;
  S.players=[newPlayer(0,true),newPlayer(1,false),newPlayer(2,false),newPlayer(3,false)];
  for(const p of S.players){ p.pyr=buildPyramid(S.deck); }
  // shared core
  S.core.card=S.deck.pop(); S.core.exposed=false; S.core.cleared=false;
  // hands (5)
  for(const p of S.players){ for(let i=0;i<5;i++) drawOne(p.seat); }
  S.turn=0; S.attempt.length=0; S.contributed.clear();
  renderAll();
  if(!S.players[0].isHuman || S.autoP1) runTurn();
}
function reshuffleIfNeeded(){
  if(S.deck.length===0 && S.reshufflesLeft>0 && S.discard.length){
    S.deck=shuffle(S.discard); S.discard=[]; S.reshufflesLeft--;
  }
}
function drawOne(seat){
  if(S.deck.length===0){ reshuffleIfNeeded(); }
  if(S.deck.length===0){ endGame(false,"Deck exhausted."); return false; }
  S.players[seat].hand.push(S.deck.pop()); return true;
}
function drawUpTo5IfEmpty(seat){
  const P=S.players[seat];
  if(P.hand.length===0){
    for(let i=0;i<5;i++){ if(!drawOne(seat)) return false; }
  }
  return true;
}

/* ======= Attempt rules ======= */
function targetRanksForActive(){
  const P=S.players[S.turn];
  const slots=exposedSlots(P).map(pos=>P.pyr.rows[pos.row][pos.col].card);
  const coreOK = S.core.exposed && S.core.card;
  const ranks = slots.map(c=>c.r);
  if(coreOK){ ranks.push(S.core.card.r); }
  return ranks;
}
function seatLeftRight(seat){ return [(seat+3)%4,(seat+1)%4]; }
function chooseBotPlay(seat){
  const P=S.players[seat]; const [L,R]=seatLeftRight(seat);
  const trySolve=(base,targetVal)=>{
    // 0 helpers
    if(isMatch(base,null,null,targetVal)) return {helpers:[]};
    // 1 helper (L then R)
    for(const hs of [L,R]){
      for(let i=0;i<S.players[hs].hand.length;i++){
        const h1=S.players[hs].hand[i];
        if(isMatch(base,h1,null,targetVal)) return {helpers:[{hs,idx:i}]};
      }
    }
    // 2 helpers (L/R combos)
    for(const hs1 of [L,R]){
      for(const hs2 of [L,R]){
        if(hs2===hs1) continue;
        for(let i=0;i<S.players[hs1].hand.length;i++){
          for(let j=0;j<S.players[hs2].hand.length;j++){
            const h1=S.players[hs1].hand[i], h2=S.players[hs2].hand[j];
            if(isMatch(base,h1,h2,targetVal)) return {helpers:[{hs:hs1,idx:i},{hs:hs2,idx:j}]};
          }
        }
      }
    }
    return null;
  };
  // Core first if exposed
  const tryList=[];
  if(S.core.exposed && S.core.card){
    tryList.push({where:"core", r:S.core.card.r, pos:null});
  }
  // Then own exposed
  const xs=exposedSlots(P);
  for(const pos of xs){
    const tc=P.pyr.rows[pos.row][pos.col].card;
    tryList.push({where:"pyr", r:tc.r, pos});
  }
  // scan base choices
  for(let bi=0; bi<P.hand.length; bi++){
    const base=P.hand[bi];
    for(const t of tryList){
      const targetVal = (t.r==="Joker") ? null : RVAL(t.r);
      const sol=trySolve(base,targetVal);
      if(sol){ return {bi,where:t.where,pos:t.pos,helpers:sol.helpers}; }
    }
  }
  // no solvable ‚Üí dump card (first)
  if(P.hand.length) return {bi:0,where:null,pos:null,helpers:[]};
  return null;
}
function isJoker(c){ return c && c.r==="Joker"; }
function isNumeric(c){ return c && !isJoker(c) && !isFace(c.r); }
function isMatch(base,h1,h2,targetVal){
  // Jokers auto-win
  if(isJoker(base) || isJoker(h1) || isJoker(h2)) return true;
  if(targetVal==null) return true; // Joker target
  if(isFace(base.r)) return false;
  const b=RVAL(base.r);
  const addPoss=(vals)=>{
    const set=new Set(vals);
    return set.has(targetVal);
  };
  // 0 helper
  if(h1==null && h2==null) return addPoss([b]);
  // 1 helper
  if(h1 && !h2){
    if(isNumeric(h1)){
      const a=RVAL(h1.r);
      return addPoss([b+a,b-a]);
    }else return true; // helper was face (ignored) ‚Üí doesn‚Äôt help; but if it were Joker we‚Äôd have returned earlier
  }
  // 2 helpers
  if(h1 && h2){
    let vec=[];
    const vs=[];
    if(isNumeric(h1)) vs.push(RVAL(h1.r)); else return true; // joker caught earlier; faces don‚Äôt add numeric, but allow? We keep conservative: if face and no joker, it doesn‚Äôt help.
    if(isNumeric(h2)) vs.push(RVAL(h2.r)); else return true;
    const [a,b2]=vs;
    vec=[b+a+b2,b+a-b2,b-a+b2,b-a-b2];
    return addPoss(vec);
  }
  return false;
}

function applyAttempt(plan){
  const P=S.players[S.turn];
  const base=P.hand.splice(plan.bi,1)[0]; S.discard.push(base);
  // take helpers out (store then remove)
  const taken=[];
  for(const h of plan.helpers){
    const c=S.players[h.hs].hand[h.idx];
    taken.push({hs:h.hs, idx:h.idx, card:c});
  }
  // remove helpers from hands (descending idx per seat)
  const bySeat=new Map();
  for(const t of taken){
    if(!bySeat.has(t.hs)) bySeat.set(t.hs,[]);
    bySeat.get(t.hs).push(t.idx);
  }
  for(const [hs,arr] of bySeat){
    arr.sort((a,b)=>b-a).forEach(i=>{ S.discard.push(S.players[hs].hand.splice(i,1)[0]); });
  }

  let success=false, clearedFace=false, clearedLabel="‚Äî";
  if(plan.where==="core"){
    // numeric/logic already checked by bot/human; here permit joker or computed success
    success=true; clearedLabel="CORE "+label(S.core.card);
  }else if(plan.where==="pyr"){
    const cell=P.pyr.rows[plan.pos.row][plan.pos.col];
    const tcard=cell.card; const targetVal = isJoker(tcard)? null : RVAL(tcard.r);
    success = isMatch(base, taken[0]?.card, taken[1]?.card, targetVal);
    if(success){
      clearedLabel=label(tcard);
      if(isFace(tcard.r)) clearedFace=true;
      // clear cell
      P.pyr.rows[plan.pos.row][plan.pos.col]=null;
      flipExposures(P);
      // expose core if top gone
      if(!P.pyr.rows[2][0]) S.core.exposed=true;
    }
  }else{
    // dump (no target)
  }

  // Post effects
  if(success){
    if(plan.where==="core"){ S.core.cleared=true; }
    // active gain: if cleared a face on pyramid ‚Üí retrieve top of discard; else draw 1
    if(clearedFace){
      if(S.discard.length>0) { P.hand.push(S.discard.pop()); }
      else drawOne(P.seat);
    }else{
      drawOne(P.seat);
    }
  }else{
    // fail ‚Üí hazard to active (face-up from deck) + active draws 1
    addHazardToActive();
    drawOne(P.seat);
  }

  // zero-hand refill rule for anyone who hit 0
  for(const pl of S.players){ if(pl.hand.length===0){ for(let i=0;i<5;i++) if(!drawOne(pl.seat)) break; } }

  // last-play compact summary
  const hStr = taken.map(t=>label(t.card)).join(", ") || "‚Äî";
  const tgt = plan.where==="core" ? ("CORE "+label(S.core.card)) :
              plan.where==="pyr"  ? label(P.pyr.rows[plan.pos.row]?.[plan.pos.col]?.card || {r:"(cleared)",s:""}) :
              "‚Äî";
  S.lastPlay = `${P.name} | Base ${label(base)} | Helpers ${hStr} | Target ${plan.where? (plan.where==="core"?"Core":tgt):"‚Äî"} | ${success?"‚úÖ Success":"‚ùå Fail"}`;

  // win/lose?
  if(S.core.cleared){ endGame(true,"Core defused! Team wins."); return; }
  // continue
  S.turn=(S.turn+1)%4; S.attempt.length=0; S.contributed.clear();
  renderAll();
  runTurn();
}

function addHazardToActive(){
  const P=S.players[S.turn];
  const order=[[0,0],[0,1],[0,2],[1,0],[1,1],[2,0]];
  if(S.deck.length===0){ reshuffleIfNeeded(); }
  if(S.deck.length===0){ endGame(false,"Deck exhausted."); return; }
  const card=S.deck.pop();
  for(const [r,c] of order){
    if(!P.pyr.rows[r][c]){
      P.pyr.rows[r][c]={card,hidden:false,hazard:true};
      break;
    }
  }
}

/* ======= Human turn helpers ======= */
let selectedHandIdx=null;
function canHumanAct(){ return S.started && !ended && S.turn===0 && !S.autoP1; }
function playSelected(){
  if(!canHumanAct() || selectedHandIdx==null) return;
  const P=S.players[0];
  // pick best plan using same bot heuristic but force base = selected
  const baseIdx=selectedHandIdx;
  const [L,R]=seatLeftRight(0);
  const trySolve=(targetVal)=>{
    if(isMatch(P.hand[baseIdx],null,null,targetVal)) return {helpers:[]};
    for(const hs of [L,R]){
      for(let i=0;i<S.players[hs].hand.length;i++){
        if(isMatch(P.hand[baseIdx], S.players[hs].hand[i], null, targetVal)) return {helpers:[{hs,idx:i}]};
      }
    }
    for(const hs1 of [L,R]) for(const hs2 of [L,R]){
      if(hs2===hs1) continue;
      for(let i=0;i<S.players[hs1].hand.length;i++)
        for(let j=0;j<S.players[hs2].hand.length;j++)
          if(isMatch(P.hand[baseIdx], S.players[hs1].hand[i], S.players[hs2].hand[j], targetVal))
            return {helpers:[{hs:hs1,idx:i},{hs:hs2,idx:j}]};
    }
    return null;
  };
  // build targets preferring core first
  const targets=[];
  if(S.core.exposed && S.core.card) targets.push({where:"core"});
  const xs=exposedSlots(P);
  for(const pos of xs){ const c=P.pyr.rows[pos.row][pos.col].card; targets.push({where:"pyr",pos,val:isJoker(c)?null:RVAL(c.r)}); }
  // scan
  for(const t of targets){
    const sol = t.where==="core" ? trySolve(S.core.card ? (isJoker(S.core.card)?null:RVAL(S.core.card.r)) : null) : trySolve(t.val);
    if(sol){ const plan={bi:baseIdx, where:t.where, pos:t.pos||null, helpers:sol.helpers}; selectedHandIdx=null; return applyAttempt(plan); }
  }
  // no match ‚Üí dump
  const plan={bi:baseIdx, where:null, pos:null, helpers:[]}; selectedHandIdx=null; applyAttempt(plan);
}
function skipHuman(){
  if(!canHumanAct()) return;
  // dump first card
  if(S.players[0].hand.length===0) return;
  const plan={bi:0, where:null, pos:null, helpers:[]};
  applyAttempt(plan);
}

/* ======= Bot flow ======= */
function runTurn(){
  if(ended || !S.started) return;
  updateBars();
  if(S.turn===0 && !S.autoP1){ // wait for human
    document.getElementById("hint").textContent="Your turn: select a card and Play Selected (bots will help automatically).";
    renderAll(); return;
  }
  // bot thinks and plays
  const plan=chooseBotPlay(S.turn) || {bi:0,where:null,pos:null,helpers:[]};
  setTimeout(()=>applyAttempt(plan), S.speed);
}

/* ======= Render ======= */
function cardEl(c, cls=""){
  const d=document.createElement("div"); d.className="card "+cls+(c.s?` s-${c.s}`:"");
  d.textContent=(c.r==="Joker")?"J‚òÖ":(c.r+GL[c.s]);
  if(c.r==="A") d.classList.add("A");
  if(isFace(c.r)) d.classList.add("face");
  return d;
}
function hiddenEl(){const d=document.createElement("div"); d.className="card dim"; d.textContent="üÇ†"; return d;}
function emptySlot(){const d=document.createElement("div"); d.className="slot"; return d;}

function renderPyramid(p){
  const wrap=document.createElement("div"); wrap.className="pyramid";
  const R=p.pyr.rows;
  const r2=document.createElement("div"); r2.className="py-row";
  r2.appendChild(R[2][0]? (R[2][0].hidden? hiddenEl() : cardEl(R[2][0].card,"")) : emptySlot()); wrap.appendChild(r2);
  const r1=document.createElement("div"); r1.className="py-row";
  for(let i=0;i<2;i++) r1.appendChild(R[1][i]? (R[1][i].hidden? hiddenEl() : cardEl(R[1][i].card,"")) : emptySlot()); wrap.appendChild(r1);
  const r0=document.createElement("div"); r0.className="py-row";
  for(let i=0;i<3;i++) r0.appendChild(R[0][i]? (R[0][i].hidden? hiddenEl() : cardEl(R[0][i].card,"")) : emptySlot()); wrap.appendChild(r0);
  // exposed highlights
  for(const ex of exposedSlots(p)){ const rows=wrap.querySelectorAll(".py-row"); const idx=(ex.row===2)?0:(ex.row===1?1:2); rows[idx].children[ex.col].classList.add("exposed"); }
  return wrap;
}
function chip(t){const s=document.createElement("span"); s.className="chip"; s.textContent=t; return s;}
function renderPlayer(p, el, showHand){
  el.innerHTML="";
  const h2=document.createElement("h2"); h2.textContent=p.name+(S.turn===p.seat?" ‚Äî Turn":""); el.appendChild(h2);
  const chips=document.createElement("div"); chips.className="chips";
  chips.appendChild(chip(`Hand: ${p.hand.length}`));
  el.appendChild(chips);
  el.appendChild(renderPyramid(p));
  const lab=document.createElement("div"); lab.className="note"; lab.textContent=showHand?"Your hand (select one):":"Hand (hidden)"; el.appendChild(lab);
  const hand=document.createElement("div"); hand.className="hand";
  if(showHand){
    p.hand.forEach((c,i)=>{const n=cardEl(c,"clickable"); if(selectedHandIdx===i) n.classList.add("selected"); n.onclick=()=>{selectedHandIdx=i; renderAll();}; hand.appendChild(n);});
  }else{
    p.hand.forEach(()=>hand.appendChild(hiddenEl()));
  }
  el.appendChild(hand);
}
function updateBars(){
  document.getElementById("turnSpan").textContent=S.started?`Turn: ${S.players[S.turn].name}`:"";
  document.getElementById("deckSpan").textContent=S.started?`Deck: ${S.deck.length}`:"";
  document.getElementById("reshuffleSpan").textContent=S.started?`Reshuffles: ${S.reshufflesLeft}`:"";
  document.getElementById("coreSpan").textContent=S.started?`Core: ${S.core.exposed?(S.core.cleared?"CLEARED":label(S.core.card)):"‚Äî"}`:"";
  document.getElementById("targetsSpan").textContent=S.started?`Your targets: ${S.turn===0?targetRanksForActive().join(", "):"‚Äî"}`:"";
  document.getElementById("attemptCount").textContent=`${S.attempt.length}/3`;
  document.getElementById("lastPlay").textContent=S.lastPlay || "‚Äî";
}
function renderAll(){
  updateBars();
  if(!S.started) return;
  renderPlayer(S.players[0], document.getElementById("p0Box"), !S.autoP1);
  renderPlayer(S.players[1], document.getElementById("p1Box"), false);
  renderPlayer(S.players[2], document.getElementById("p2Box"), false);
  renderPlayer(S.players[3], document.getElementById("p3Box"), false);
  document.getElementById("playBtn").disabled=!(canHumanAct() && selectedHandIdx!=null);
  document.getElementById("skipBtn").disabled=!canHumanAct();
}

/* ======= End game ======= */
function endGame(win,msg){
  if(ended) return; ended=true; S.started=false;
  document.getElementById("hint").textContent=(win?"üèÜ ":"üí• ")+msg+"  Click New Game to restart.";
  renderAll();
}

/* ======= Wire up ======= */
document.getElementById("newBtn").onclick=()=>{ selectedHandIdx=null; startGame(); };
document.getElementById("speedSel").onchange=e=>{ S.speed=+e.target.value; };
document.getElementById("autoP1").onchange=e=>{ S.autoP1=e.target.checked; renderAll(); if(S.autoP1 && S.turn===0) runTurn(); };
document.getElementById("playBtn").onclick=playSelected;
document.getElementById("skipBtn").onclick=skipHuman;

/* Boot */
renderAll();
</script>
</body>
</html>
